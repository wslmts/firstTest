 这是一个简单的音调产生器的范例。
requestSoundData() 是产生音频样本的函式，这个函式在经过某个特定的时间间隔会透过 setInterval() 被呼叫。
mozWriteAudio() 是在被呼叫时，把样本写入音频串流的函式。
为了确保总是有可以播放的样本，这个范例设置了一个 500 ms 的缓冲。
mozCurrentSampleOffset() 是一个用来知道正在被播放的样本所在位置的函式，这的函式被这个范例用来确保我们填进缓冲的总是正在被播放后的 500 ms。
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript 音频写入范例</title>
  </head>
  <body>
    <input type="text" size="4" id="freq" value="440"><label for="hz">Hz</label>
    <button onclick="start()">play</button>
    <button onclick="stop()">stop</button>

    <script type="text/javascript">      
      function AudioDataDestination(sampleRate, readFn) {
        // 音频输出的初使化
        var audio = new Audio();
        audio.mozSetup(1, sampleRate);

        var currentWritePosition = 0;
        var prebufferSize = sampleRate / 2; // 缓冲 500ms
        var tail = null;

        // 这个函数会被定期呼叫以填充音频输出缓冲
        setInterval(function() {
          var written;
          // 看看之前也没有留下未被写入的资料
          if(tail) {  
            written = audio.mozWriteAudio(tail);
            currentWritePosition += written;
            if(written < tail.length) {
              // 并非所有数据都被写入了，把剩下的存下来...
              tail = tail.slice(written);
              return; // ... 并结束这个函式
            }
            tail = null;
          }

          // 看看是不是有需要再加新数据至音频输出
          var currentPosition = audio.mozCurrentSampleOffset();
          var available = currentPosition + prebufferSize - currentWritePosition;
          if(available > 0) {
            // 从回拨函式（callback）要一些音效数据
            var soundData = new Float32Array(parseFloat(available));
            readFn(soundData);

            // 写这些资料
            written = audio.mozWriteAudio(soundData);
            if(written < soundData.length) {
              // 不是所有数据都被写入了，存下剩下的部份。
              tail = soundData.slice(written);
            }
            currentWritePosition += written;
          }
        }, 100);
      }

      // 控制并制造声音

      var frequency = 0, currentSoundSample;
      var sampleRate = 44100;

      function requestSoundData(soundData) {
        if (!frequency) { 
          return; // 已被静音
        }

        var k = 2* Math.PI * frequency / sampleRate;
        for (var i=0, size=soundData.length; i<size; i++) {
          soundData[i] = Math.sin(k * currentSoundSample++);
        }        
      }

      var audioDestination = new AudioDataDestination(sampleRate, requestSoundData);

      function start() {
        currentSoundSample = 0;
        frequency = parseFloat(document.getElementById("freq").value);
      }

      function stop() {
        frequency = 0;
      }
  </script>
  </body>
</html>
